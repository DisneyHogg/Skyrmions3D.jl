        - """
        -     product_approx!(skyrmion1,skyrmion2) 
        - 
        - Makes the symmetrised product approximation of `skyrmion1` and `skyrmion2`. The output is written in to `skyrmion1`. The returned field is normalised.
        - 
        - See also [`product_approx`]
        - """
        1 function product_approx!(sk1, sk2)
        - 
        1     check_grids(sk1,sk2)
        - 
        1     lp = sk1.lp
        1     tempsk = deepcopy(sk1)
        - 
       26     for k in 1:lp[3], j in 1:lp[2], i in 1:lp[1]
      125         tempsk.pion_field[i,j,k,:] = product_approx_pt(sk1,sk2,i,j,k)
      129     end
        - 
        1     normer!(tempsk)
        1     sk1.pion_field .= tempsk.pion_field
        - 
        - end
        - 
        - """
        -     product_approx(skyrmion1,skyrmion2) -> product_skyrmion
        - 
        - Returns the symmetrised product approximation of `skyrmion1` and `skyrmion2`. The returned field is normalised.
        - 
        - See also [`product_approx!`]
        - """
        2 function product_approx(sk1, sk2)
        - 
        2     check_grids(sk1,sk2)
        - 
        1     lp = sk2.lp
        - 
        1     tempsk = deepcopy(sk1)
        - 
       26     for k in 1:lp[3], j in 1:lp[2], i in 1:lp[1] 
      125         tempsk.pion_field[i,j,k,:] = product_approx_pt(sk1,sk2,i,j,k)
      129     end
        - 
        1     normer!(tempsk)
        - 
        1     return tempsk
        - 
        - end
        - 
        3 function check_grids(sk1,sk2)
        3     if sk1.x != sk2.x
        1         error("skyrmion grids are not equal")
        2         return
        -     end
        - end
        - 
      250 function product_approx_pt(sk1, sk2, i, j, k)
        - 
      250     temp_pt = MVector{4, Float64}(0.0, 0.0, 0.0, 0.0)
        - 
      250     temp_pt[4] = sk1.pion_field[i,j,k,4]*sk2.pion_field[i,j,k,4] 
      250     for a in 1:3
      750         temp_pt[a] = sk1.pion_field[i,j,k,a]*sk2.pion_field[i,j,k,4] + sk1.pion_field[i,j,k,4]*sk2.pion_field[i,j,k,a]
      750         temp_pt[4] -= sk1.pion_field[i,j,k,a]*sk2.pion_field[i,j,k,a] 
     1250     end
        - 
      250     return temp_pt
        - 
        - end
        - 
        - 
        - 
        - """
        -     translate_sk(skyrmion,X) -> translated_skyrmion
        - 
        - Returns `skyrmion` translated by 3-Vector `X`, e.g. `X = [1.0, 0.0, 0.0]`
        - 
        - See also [`translate_sk!`]
        - """
        6 function translate_sk(skyrmion, X)
        - 
        6     x = skyrmion.x
        6     lp = skyrmion.lp
        - 
        6     sky_temp = deepcopy(skyrmion)
        - 
       24     vac = [0.0,0.0,0.0,1.0]
        - 
        6     ϕinterp = [ extrapolate(scale(interpolate( skyrmion.pion_field[:,:,:,a] , BSpline(Quadratic()) ), (x[1],x[2],x[3]) ), Throw()) for a in 1:4 ]
        - 
      606     for a in 1:4, k in 1:lp[3], j in 1:lp[2], i in 1:lp[1]
     3000         if x[1][i] > x[1][1] + X[1] && x[1][i] < x[1][end] + X[1] && x[2][j] > x[2][1] + X[2] && x[2][j] < x[2][end] + X[2] && x[3][k] > x[3][1] + X[3] && x[3][k] < x[3][end] + X[3]
      648             sky_temp.pion_field[i,j,k,a] = ϕinterp[a](x[1][i] - X[1], x[2][j] - X[2], x[3][k] - X[3])
        -         else
     2352             sky_temp.pion_field[i,j,k,a] = vac[a]
        -         end
     3018     end
        - 
        6     normer!(sky_temp)
        - 
        6     return sky_temp
        - 
        - end
        - 
        - """
        -     translate_sk!(skyrmion,X)
        - 
        - Translates `skyrmion` by the 3-Vector `X`, e.g. `X = [1.0, 0.0, 0.0]`
        - 
        - See also [`translate_sk`]
        - """
        6 function translate_sk!(skyrmion,X)
        - 
        6     x = skyrmion.x
        6     lp = skyrmion.lp
        - 
        6     sky_temp = deepcopy(skyrmion)
        - 
       24     vac = [0.0,0.0,0.0,1.0]
        - 
        6     ϕinterp = [ extrapolate(scale(interpolate( skyrmion.pion_field[:,:,:,a] , BSpline(Quadratic()) ), (x[1],x[2],x[3]) ), Throw()) for a in 1:4 ]
        - 
      606     for a in 1:4, k in 1:lp[3], j in 1:lp[2], i in 1:lp[1]
     3000         if x[1][i] > x[1][1] + X[1] && x[1][i] < x[1][end] + X[1] && x[2][j] > x[2][1] + X[2] && x[2][j] < x[2][end] + X[2] && x[3][k] > x[3][1] + X[3] && x[3][k] < x[3][end] + X[3]
      540             sky_temp.pion_field[i,j,k,a] = ϕinterp[a](x[1][i] - X[1], x[2][j] - X[2], x[3][k] - X[3])
        -         else
     2460             sky_temp.pion_field[i,j,k,a] = vac[a]
        -         end
     3018     end
        - 
      156     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3], a in 1:4
     3000         skyrmion.pion_field[i,j,k,a] = sky_temp.pion_field[i,j,k,a]
     3024     end
        - 
        6     normer!(skyrmion)
        - 
        - end
        - 
        - """
        -     isorotate_sk!(skyrmion,θ,n)
        - 
        - Isorotates `skyrmion` by `θ` around the vector `n`. The given vector is automatically normalised.
        - 
        - See also [`isorotate_sk!`]
        - 
        - 
        - """
        1 function isorotate_sk!(skyrmion,θ,n)
        - 
        3     if n == [0.0, 0.0, 0.0]
        0         error("Your vector is zero.")
        0         return
        -     end
        - 
        1     rotation_matrix = R_from_axis_angle(θ,n)
        - 
        1     lp = skyrmion.lp
        - 
        1     tempsk = deepcopy(skyrmion)
        - 
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3], a in 1:3
      375         tempsk.pion_field[i,j,k,a] = 0.0
      379     end
        - 
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3]
        - 
      125         for a in 1:3, b in 1:3
     1125             tempsk.pion_field[i,j,k,a] += rotation_matrix[a,b]*skyrmion.pion_field[i,j,k,b]
     1375         end
        - 
      125         tempsk.pion_field[i,j,k,4] = skyrmion.pion_field[i,j,k,4]
        - 
      129     end
        - 
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3], a in 1:4
      500         skyrmion.pion_field[i,j,k,a] = tempsk.pion_field[i,j,k,a]
      504     end
        - 
        1     normer!(skyrmion)
        - 
        - end
        - 
        - """
        -     isorotate_sk(skyrmion,θ,n) -> isorotated_skyrmion
        - 
        - Returns `skyrmion` isorotated by `θ` around the vector `n`. The given vector is automatically normalised.
        - 
        - See also [`isorotate_sk!`]
        - """
        1 function isorotate_sk(skyrmion,θ,n)
        - 
        3     if n == [0.0, 0.0, 0.0]
        0         error("Your vector is zero.")
        0         return
        -     end
        - 
        1     rotation_matrix = R_from_axis_angle(θ,n)
        - 
        1     tempsk = deepcopy(skyrmion)
        - 
        1     lp = skyrmion.lp
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3], a in 1:3
      375         tempsk.pion_field[i,j,k,a] = 0.0
      379     end
        - 
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3]
        - 
      125         for a in 1:3, b in 1:3
     1125             tempsk.pion_field[i,j,k,a] += rotation_matrix[a,b]*skyrmion.pion_field[i,j,k,b]
     1375         end
        - 
      125         tempsk.pion_field[i,j,k,4] = skyrmion.pion_field[i,j,k,4]
        - 
      129     end
        - 
        1     normer!(tempsk)
        - 
        1     return tempsk
        - 
        - end
        - 
        - 
        - 
        - """
        -     rotate_sk!(skyrmion,θ,n)
        - 
        - Rotates `skyrmion` by `θ` around the vector `n`. The given vector is automatically normalised.
        - 
        - See also [`rotate_sk`]
        - """
        1 function rotate_sk!(skyrmion,θ,n)
        - 
        3     if n == [0.0, 0.0, 0.0]
        0         error("Your vector is zero.")
        0         return
        -     end
        - 
        1     rotation_matrix = R_from_axis_angle(θ,n)
        - 
        1     lp = skyrmion.lp
        1     x = skyrmion.x
        - 
        1     sky_temp = deepcopy(skyrmion)
        - 
        4     vac = [0.0,0.0,0.0,1.0]
        - 
        1     ϕinterp = [ extrapolate(scale(interpolate( skyrmion.pion_field[:,:,:,a] , BSpline(Quadratic()) ), (x[1],x[2],x[3]) ), Throw()) for a in 1:4 ]
        - 
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3]
        - 
      375         newx = rotation_matrix*[ x[1][i], x[2][j], x[3][k] ]
        - 
      125         if x[1][1] < newx[1] < x[1][end] && x[2][1] < newx[2] < x[2][end] && x[3][1] < newx[3] < x[3][end] 
       51             for a in 1:4    
      204                     sky_temp.pion_field[i,j,k,a] = ϕinterp[a](newx[1], newx[2], newx[3])
      357             end
        -         else 
       74             for a in 1:4    
      296                 sky_temp.pion_field[i,j,k,a] = vac[a]
      296             end
        -         end
      129     end
        - 
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3], a in 1:4
      500         skyrmion.pion_field[i,j,k,a] = sky_temp.pion_field[i,j,k,a]
      504     end
        - 
        1     normer!(skyrmion)
        - 
        - end
        - 
        - 
        - """
        -     rotate_sk(skyrmion,θ,n) -> rotated_skyrmion
        - 
        - Returns `skyrmion` rotated by `θ` around the vector `n`. The given vector is automatically normalised.
        - 
        - See also [`rotate_sk!`]
        - """
        1 function rotate_sk(skyrmion,θ,n)
        - 
        3     if n == [0.0, 0.0, 0.0]
        0         error("Your vector is zero.")
        0         return
        -     end
        - 
        1     rotation_matrix = R_from_axis_angle(θ,n)
        - 
        1     lp = skyrmion.lp
        1     x = skyrmion.x
        - 
        1     sky_temp = deepcopy(skyrmion)
        - 
        4     vac = [0.0,0.0,0.0,1.0]
        - 
        1     ϕinterp = [ extrapolate(scale(interpolate( skyrmion.pion_field[:,:,:,a] , BSpline(Quadratic()) ), (x[1],x[2],x[3]) ), Throw()) for a in 1:4 ]
        - 
       26     for i in 1:lp[1], j in 1:lp[2], k in 1:lp[3]
        - 
      375         newx = rotation_matrix*[ x[1][i], x[2][j], x[3][k] ]
        - 
      125         if x[1][1] < newx[1] < x[1][end] && x[2][1] < newx[2] < x[2][end] && x[3][1] < newx[3] < x[3][end] 
       69             for a in 1:4    
      276                     sky_temp.pion_field[i,j,k,a] = ϕinterp[a](newx[1], newx[2], newx[3])
      483             end
        -         else 
       56             for a in 1:4    
      224                 sky_temp.pion_field[i,j,k,a] = vac[a]
      224             end
        -         end
      129     end
        - 
        1     normer!(sky_temp)
        - 
        1     return sky_temp
        - 
        - end
        - 
        - """
        -     center_skyrmion(my_skyrmion)
        - 
        - Translates `skyrmion' so that the center of mass is `(0,0,0)'.
        - 
        - """
        1 function center_skyrmion!(sk)
        - 
        1     for _ in 1:5
        5         current_CoM = center_of_mass(sk)
        5         translate_sk!(sk,-current_CoM)
        5     end
        -     
        - end
        - 
        - """
        -     set_dirichlet!(skyrmion; vac = [0.0,0.0,0.0,1.0])
        - 
        -     Sets the boundary of `skyrmion` equal to `vac`, with default value `[0.0, 0.0, 0.0, 1.0]`
        - 
        - """
       17 function set_dirichlet_boudary!(sk; vac=[0.0,0.0,0.0,1.0])
        - 
       27     for i in 1:sk.lp[1], j in 1:sk.lp[2]
      218         sk.pion_field[i,j,1,:] .= vac
      218         sk.pion_field[i,j,2,:] .= vac
      218         sk.pion_field[i,j,sk.lp[3],:] .= vac
      218         sk.pion_field[i,j,sk.lp[3]-1,:] .= vac
      128     end
        -     
       29     for k in 1:sk.lp[3], j in 1:sk.lp[2]
      234         sk.pion_field[1,j,k,:] .= vac
      234         sk.pion_field[2,j,k,:] .= vac
      234         sk.pion_field[sk.lp[1],j,k,:] .= vac
      234         sk.pion_field[sk.lp[1]-1,j,k,:] .= vac
      138     end
        -     
       29     for k in 1:sk.lp[3], i in 1:sk.lp[1]
      290         sk.pion_field[i,1,k,:] .= vac
      290         sk.pion_field[i,2,k,:] .= vac
      290         sk.pion_field[i,sk.lp[2],k,:] .= vac
      290         sk.pion_field[i,sk.lp[2]-1,k,:] .= vac
      145     end
        -     
        - end
