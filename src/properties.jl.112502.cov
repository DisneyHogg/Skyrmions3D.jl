        - """
        -     overview(skyrmion)
        - 
        - Displays an overview of `skyrmion`'s properties.
        - 
        - """
        1 function overview(sk)
        - 
        1     hbar = 197
        - 
        1     println("This skyrmion is on a ", sk.lp[1],"x",sk.lp[2],"x",sk.lp[3]," grid, with lattice spacing [", sk.ls[1],", ", sk.ls[2],", ", sk.ls[3], "]. ")
        1     println("The boundary conditions are "*sk.boundary_conditions)
        1     println()
        1     println("            m = ", round(sk.mpi, sigdigits=5) ) 
        1     println("Baryon number = ", round(Baryon(sk), sigdigits=5) ) 
        1     println("       Energy = ", round(12*pi*pi*Energy(sk), sigdigits=5) ) 
        1     println("   Baryon rms = ", round(rms_baryon(sk), sigdigits=5) ) 
        1     println()
        1     println("With physical constants Fpi = ", sk.Fpi, " and e = ", sk.ee,",")
        1     println("the energy and length units are ", round(sk.Fpi/(4*sk.ee),sigdigits=4), " MeV and ", round(hbar*2/(sk.ee*sk.Fpi),sigdigits=4), " fm." )
        1     println("So physical E = ", round(12*pi*pi*Energy(sk)*sk.Fpi/(4*sk.ee), sigdigits=5), " MeV." )
        1     println("   Baryon rms = ", round(rms_baryon(sk)*2*hbar/(sk.ee*sk.Fpi), sigdigits=5), " fm." ) 
        - 
        - end
        - 
        - 
        - """
        -     Energy(skyrmion; density=false)
        - 
        - Compute energy of `skyrmion`.
        - 
        - Set 'density = true' to output the energy density and moment to `n` to calculate the nth moment of the energy density.
        - 
        - """
       12 function Energy(sk; density=false, moment=0)
        - 
      750     ED = zeros(sk.lp[1], sk.lp[2], sk.lp[3])
        - 
        6     get_energy_density!(ED,sk,moment=moment)
        - 
        6     if density == false
        5         engtot = sum(ED)*sk.ls[1]*sk.ls[2]*sk.ls[3]
        5         if sk.physical == false
        5             return engtot/(12.0*pi^2)
        -         else
        0             if moment == 0
        0                 return (engtot*sk.Fpi/(4.0*sk.ee), "MeV" )
        -             else
        0                 return (engtot*sk.Fpi*(197.327*2.0/(sk.ee*sk.Fpi))/(4.0*sk.ee), "MeV fm^"*string(moment))
        -             end
        -         end
        -     else
        1         return ED
        -     end
        - 
        - end 
        - 
       12 function get_energy_density!(density, sk ;moment=0)
        - 
        6     Threads.@threads for k in sk.sum_grid[3]
       68         @inbounds for j in sk.sum_grid[2], i in sk.sum_grid[1]
        -         
      485             dp = getDP(sk ,i, j, k )
      238             rm = sqrt( sk.x[1][i]^2 + sk.x[2][j]^2 + sk.x[3][k]^2 )^moment
        - 
      247             density[i,j,k] = engpt(dp,sk.pion_field[i,j,k,4],sk.mpi) * rm
        - 
        -         
      284         end
        0     end
        - 
        - end
        - 
      255 function engpt(dp,p4,mpi)
        - 
      255     return 2*mpi^2*(1 - p4) + (dp[1,1]^2 + dp[1,2]^2 + dp[1,3]^2 + dp[1,4]^2 + dp[2,1]^2 + dp[2,2]^2 + dp[2,3]^2 + dp[2,4]^2 + dp[3,1]^2 + dp[3,2]^2 + dp[3,3]^2 + dp[3,4]^2) + (dp[1,4]^2*dp[2,1]^2 + dp[1,4]^2*dp[2,2]^2 + dp[1,4]^2*dp[2,3]^2 + dp[1,1]^2*(dp[2,2]^2 + dp[2,3]^2) - 2*dp[1,1]*dp[1,4]*dp[2,1]*dp[2,4] + dp[1,1]^2*dp[2,4]^2 + dp[1,4]^2*dp[3,1]^2 + dp[2,2]^2*dp[3,1]^2 + dp[2,3]^2*dp[3,1]^2 + dp[2,4]^2*dp[3,1]^2 - 2*dp[2,1]*dp[2,2]*dp[3,1]*dp[3,2] + dp[1,1]^2*dp[3,2]^2 + dp[1,4]^2*dp[3,2]^2 + dp[2,1]^2*dp[3,2]^2 + dp[2,3]^2*dp[3,2]^2 + dp[2,4]^2*dp[3,2]^2 - 2*dp[2,1]*dp[2,3]*dp[3,1]*dp[3,3] - 2*dp[2,2]*dp[2,3]*dp[3,2]*dp[3,3] + dp[1,1]^2*dp[3,3]^2 + dp[1,4]^2*dp[3,3]^2 + dp[2,1]^2*dp[3,3]^2 + dp[2,2]^2*dp[3,3]^2 + dp[2,4]^2*dp[3,3]^2 - 2*(dp[1,1]*dp[1,4]*dp[3,1] + dp[2,4]*(dp[2,1]*dp[3,1] + dp[2,2]*dp[3,2] + dp[2,3]*dp[3,3]))*dp[3,4] + (dp[1,1]^2 + dp[2,1]^2 + dp[2,2]^2 + dp[2,3]^2)*dp[3,4]^2 + dp[1,3]^2*(dp[2,1]^2 + dp[2,2]^2 + dp[2,4]^2 + dp[3,1]^2 + dp[3,2]^2 + dp[3,4]^2) + dp[1,2]^2*(dp[2,1]^2 + d
        - 
        - end
        - 
        - """
        -     Baryon(skyrmion; density=false)
        - 
        - Compute baryon number of `skyrmion`.
        - 
        - Set 'density = true' to output the baryon density and moment to `n` to calculate the nth moment of the baryon density.
        - 
        - """
       12 function Baryon(sk; density=false, moment = 0)
        - 
      750     BD = zeros(sk.lp[1],sk.lp[2],sk.lp[3])
        -     
        6     get_baryon_density!(BD,sk,moment=moment)
        - 
        6     if density == false
        5         bartot = sum(BD)*sk.ls[1]*sk.ls[2]*sk.ls[3]/(2.0*pi^2)
        5         return bartot
        -     else
        1         return BD
        -     end
        -     
        - end 
        - 
       12 function get_baryon_density!(baryon_density, sk ;moment=0)
        - 
        6     Threads.@threads for k in sk.sum_grid[3]
       12         @inbounds for j in sk.sum_grid[2], i in sk.sum_grid[1]
        -         
        6             pp = getX(sk,i,j,k)
        6             dp = getDP(sk ,i, j, k )
        6             rm = sqrt( sk.x[1][i]^2 + sk.x[2][j]^2 + sk.x[3][k]^2 )^moment
        -             
        6             baryon_density[i,j,k] = barypt(dp,pp) * rm
        - 
        6         end
        0     end
        - 
        - end
        - 
        6 function barypt(dp,pp)
        6     return pp[4]*dp[1,3]*dp[2,2]*dp[3,1] - pp[3]*dp[1,4]*dp[2,2]*dp[3,1] - pp[4]*dp[1,2]*dp[2,3]*dp[3,1] + pp[2]*dp[1,4]*dp[2,3]*dp[3,1] + pp[3]*dp[1,2]*dp[2,4]*dp[3,1] - pp[2]*dp[1,3]*dp[2,4]*dp[3,1] - pp[4]*dp[1,3]*dp[2,1]*dp[3,2] + pp[3]*dp[1,4]*dp[2,1]*dp[3,2] + pp[4]*dp[1,1]*dp[2,3]*dp[3,2] - pp[1]*dp[1,4]*dp[2,3]*dp[3,2] - pp[3]*dp[1,1]*dp[2,4]*dp[3,2] + pp[1]*dp[1,3]*dp[2,4]*dp[3,2] + pp[4]*dp[1,2]*dp[2,1]*dp[3,3] - pp[2]*dp[1,4]*dp[2,1]*dp[3,3] - pp[4]*dp[1,1]*dp[2,2]*dp[3,3] + pp[1]*dp[1,4]*dp[2,2]*dp[3,3] + pp[2]*dp[1,1]*dp[2,4]*dp[3,3] - pp[1]*dp[1,2]*dp[2,4]*dp[3,3] - pp[3]*dp[1,2]*dp[2,1]*dp[3,4] + pp[2]*dp[1,3]*dp[2,1]*dp[3,4] + pp[3]*dp[1,1]*dp[2,2]*dp[3,4] - pp[1]*dp[1,3]*dp[2,2]*dp[3,4] - pp[2]*dp[1,1]*dp[2,3]*dp[3,4] + pp[1]*dp[1,2]*dp[2,3]*dp[3,4]
        - end
        - 
        - 
        - """
        -     center_of_mass(skyrmion; density=false, moment=0)
        - 
        - Compute the center of mass of `skyrmion`, based on the energy density.
        - 
        - """
        7 function center_of_mass(sk)
        - 
       21     com = zeros(3)
        - 
        7     the_engpt = 0.0
        7     toteng = 0.0
        - 
       14     @inbounds for i in 3:sk.lp[1]-2, j in 3:sk.lp[2]-2, k in 3:sk.lp[3]-2
        -     
       13         dp = getDP(sk ,i, j, k )
        - 
        7         the_engpt = engpt(dp,sk.pion_field[i,j,k,4],sk.mpi)
        - 
        7         com[1] += the_engpt*sk.x[1][i]
        7         com[2] += the_engpt*sk.x[2][j]
        7         com[3] += the_engpt*sk.x[3][k]
        - 
        7         toteng += the_engpt
        -    
        7     end
        - 
       13     if toteng â‰ˆ 0.0
        1         return [0.0,0.0,0.0]
        -     else
        6         return com/toteng
        -     end
        - 
        - end 
        - 
        - 
        - """
        -     rms_baryon(skyrmion)
        - 
        - Compute root mean square charge radius of a skyrmion, using the baryon density.
        - """
        3 function rms_baryon(sk)
        - 
        3     B0 = Baryon(sk; moment = 0)
        3     if B0 == 0.0
        3         return 0.0
        -     end
        - 
        0     if sk.physical == false
        0         return sqrt(Baryon(sk; moment = 2)/B0)
        -     else
        0         return ( sqrt(Baryon(sk; moment = 2)/B0)*197.327*(2.0/(sk.ee*sk.Fpi)), "fm" )
        -     end
        - 
        - end
        - 
        - 
        - """
        -     compute_current(skyrmion; label="uMOI", indices=[0,0], density = false, moment=0)
        - 
        - Compute a variety of currents in the Skyrme model, based on a `skyrmion`. 
        - 
        - You can calculate specific indices using e.g. `indices = [1,2]`. If `indices = [0,0]`, the function will calculate all indices. If `density = false`, the function will return the integrated densities, while `density = true` it will return the densities. 
        - 
        - The possible currents are (currently):
        - - `uMOI`: the isospin moment of inertia.
        - - `wMOI`: the mixed moment of inertia.
        - - `vMOI`: the spin moment of inertia.
        - - `uAxial`: the u-axial moment of inertia.
        - - `wAxial`: the w-axial moment of inertia.
        - - `NoetherIso`: the Noether vector current.
        - - `NoetherAxial`: the Noether axial current.
        - 
        - """
       36 function compute_current(sk; label="NULL", indices=[0,0], density=false, moment=0  )
        - 
       18     if label != "energy" && label != "uMOI" && label != "wMOI" && label != "vMOI" && label != "uAxial" && label != "wAxial" && label != "NoetherIso" && label != "NoetherAxial" && label != "stress"
        0         println("input label '", label, "' unknown. Type '?compute_current' for help.")
        0         return
        -     end
        - 
    20250     current_density = zeros(3,3,sk.lp[1],sk.lp[2],sk.lp[3])
        - 
       18     aindices = 1:3
       18     bindices = 1:3
        - 
        - 
       18     if indices != [0,0]
        9         aindices = indices[1]:indices[1]
        9         bindices = indices[2]:indices[2]
        -     end
        -     
        - 
       36    for k in sk.sum_grid[3]
       36         @inbounds for j in sk.sum_grid[2], i in sk.sum_grid[1]
        - 
       54             KD = diagm([1.0,1.0,1.0])
        - 
       18             xxx = SVector{3,Float64}(sk.x[1][i], sk.x[2][j], sk.x[3][k] )
       18             rm = sqrt( xxx[1]^2 + xxx[2]^2 + xxx[3]^2 )^moment
        - 
       18             p = getX(sk,i,j,k)
       18             dp = getDP(sk,i,j,k)
        - 
       18             if label == "uMOI"
        - 
        4                 Tiam, Lia = getTiam(p), getLka(p,dp)
        - 
       12                 for a in aindices, b in bindices
       20                     current_density[a,b,i,j,k] = -trace_su2_ij(Tiam,Tiam,a,b)*rm
       20                     for c in 1:3
       60                         current_density[a,b,i,j,k] -= 0.25*trace_su2_ijkl(Tiam,Lia,Tiam,Lia,a,c,b,c)*rm
      100                     end
       24                 end
        - 
       14             elseif label == "wMOI"
        - 
        2                 Tiam, Lia = getTiam(p), getLka(p,dp)
        2                 Gia = -1.0.*getGia(Lia,xxx)
        - 
        6                 for a in aindices, b in bindices
       10                     current_density[a,b,i,j,k] = -trace_su2_ij(Gia,Tiam,a,b)*rm
       10                     for c in 1:3
       30                         current_density[a,b,i,j,k] -= 0.25*trace_su2_ijkl(Gia,Lia,Tiam,Lia,a,c,b,c)*rm
       50                     end
       10                 end
        - 
       12             elseif label == "vMOI"
        - 
        2                 Lia = getLka(p,dp)
        2                 Gia = -1.0.*getGia(Lia,xxx)
        - 
        6                 for a in aindices, b in bindices
       10                     current_density[a,b,i,j,k] = -trace_su2_ij(Gia,Gia,a,b)*rm
       10                     for c in 1:3
       30                         current_density[a,b,i,j,k] -= 0.25*trace_su2_ijkl(Gia,Lia,Gia,Lia,a,c,b,c)*rm
       50                     end
       10                 end
        - 
       10             elseif label == "uAxial"
        - 
        2                 Tiam, Tiap, Lia = getTiam(p), getTiap(p), getRka(p,dp)
        - 
        6                 for a in aindices, b in bindices
       10                     current_density[a,b,i,j,k] = -trace_su2_ij(Tiam,Tiap,a,b)*rm
       10                     for c in 1:3
       30                         current_density[a,b,i,j,k] -= 0.25*trace_su2_ijkl(Tiam,Lia,Tiap,Lia,a,c,b,c)*rm
       50                     end
       10                 end
        - 
        8             elseif label == "wAxial"
        - 
        2                 Tiap, Lia = getTiap(p), getLka(p,dp)
        2                 Gia = -1.0.*getGia(Lia,xxx)
        - 
        6                 for a in aindices, b in bindices
       10                     current_density[a,b,i,j,k] = trace_su2_ij(Tiap,Gia,a,b) *rm
       10                     for c in 1:3
       30                         current_density[a,b,i,j,k] += 0.25*trace_su2_ijkl(Tiap,Lia,Gia,Lia,a,c,b,c)*rm
       50                     end
       10                 end
        - 
        6             elseif label == "energy"
        - 
        0                 Lia = getLka(p,dp)
        - 
        0                 for a in aindices, b in bindices
        -                     
        0                     current_density[a,b,i,j,k] += 3*2/3*(sk.mpi^2)*(1.0 - p[4])*KD[a,b]*rm
        -                     
        0                     current_density[a,b,i,j,k] -= 0.5*trace_su2_ij(Lia,Lia,a,b)*rm
        -                   
        0                     for c in 1:3
        - 
        0                        current_density[a,b,i,j,k] -= 1/16.0*trace_su2_ijkl(Lia,Lia,Lia,Lia,a,c,b,c)*rm
        -            
        0                     end
        -                     
        0                 end
        -                 
        - 
        6             elseif label == "stress"
        - 
        2                 Lia = getLka(p,dp)
        - 
        6                 for a in aindices, b in bindices
        - 
        -                     
        -                     
       10                     current_density[a,b,i,j,k] -= 2.0*(sk.mpi^2)*(1.0 - p[4])*KD[a,b]*rm
        -                     
       10                     current_density[a,b,i,j,k] -= trace_su2_ij(Lia,Lia,a,b)*rm
        - 
       10                     for c in 1:3
        - 
       30                         current_density[a,b,i,j,k] += 0.5*trace_su2_ij(Lia,Lia,c,c)*KD[a,b]*rm
        -                         
       30                         current_density[a,b,i,j,k] -= 1/4.0*trace_su2_ijkl(Lia,Lia,Lia,Lia,a,c,b,c)*rm
        - 
       30                         for d in 1:3
       90                             current_density[a,b,i,j,k] += 1/16.0*trace_su2_ijkl(Lia,Lia,Lia,Lia,c,d,c,d)*KD[a,b]*rm
      150                         end
       50                     end
        -                     
       10                 end
        - 
        4             elseif label == "NoetherIso"
        - 
        2                 Lia, Tiam = getLka(p,dp), getTiam(p)
        - 
        6                 for a in aindices, b in bindices
        - 
       10                     current_density[a,b,i,j,k] -= trace_su2_ij(Lia,Tiam,b,a)*rm
        - 
       10                     for c in 1:3
       30                         current_density[a,b,i,j,k] -= 0.25*trace_su2_ijkl(Lia,Lia,Lia,Tiam,c,b,a,c)*rm
       50                     end
        - 
       10                 end
        2             elseif label == "NoetherAxial"
        - 
        2                 Lia, Tiap = getLka(p,dp), getTiap(p)
        - 
        6                 for a in aindices, b in bindices
        - 
       10                     current_density[a,b,i,j,k] += trace_su2_ij(Lia,Tiap,b,a)*rm
        - 
       10                     for c in 1:3
       30                         current_density[a,b,i,j,k] += 0.25*trace_su2_ijkl(Lia,Lia,Lia,Tiap,c,b,a,c)*rm
       50                     end
        - 
       10                 end
        -             
        -             end
        - 
        -         
       18         end
        - 
       18     end
        - 
       32     if ( label == "uMOI" || label == "wMOI" || label == "vMOI" ) && sk.physical == true
        0         println("Using physical units, result is in MeV fm^2.")
        0         current_density .*= 197^2/(sk.Fpi*sk.ee^3)
        -     end
        - 
       18     if density == false
      144         tot_den = zeros(3,3)
       48         for a in aindices, b in bindices
       80             tot_den[a,b] = sum(current_density[a,b,:,:,:])*sk.ls[1]*sk.ls[2]*sk.ls[3]
       96         end
       16         if indices == [0,0]
        8             return tot_den
        -         else
        8             return tot_den[aindices,bindices]
        -         end
        -     else
        2         if indices == [0,0]
        1             return current_density
        -         else
        1             return current_density[aindices,bindices,:,:,:]
        -         end
        -     end
        -     
        - 
        - end
        - 
        - 
        6 function getGia(Lia,x)
        - 
        6     return SMatrix{3,3,Float64, 9}(
        -         Lia[3,1]*x[2] - Lia[2,1]*x[3],
        -         -Lia[3,1]*x[1] + Lia[1,1]*x[3],
        -         Lia[2,1]*x[1] - Lia[1,1]*x[2],
        -         Lia[3,2]*x[2] - Lia[2,2]*x[3],
        -         -Lia[3,2]*x[1] + Lia[1,2]*x[3],
        -         Lia[2,2]*x[1] - Lia[1,2]*x[2],
        -         Lia[3,3]*x[2] - Lia[2,3]*x[3],
        -         -Lia[3,3]*x[1] + Lia[1,3]*x[3],
        -         Lia[2,3]*x[1] - Lia[1,3]*x[2]
        -     )
        - 
        - end
        - 
       10 function getTiam(p)
        - 
       10     return SMatrix{3,3,Float64, 9}(
        -         -p[2]^2 - p[3]^2,
        -         p[1]*p[2] - p[3]*p[4],
        -         p[1]*p[3] + p[2]*p[4],
        -         p[1]*p[2] + p[3]*p[4],
        -         -p[1]^2 - p[3]^2,
        -         p[2]*p[3] - p[1]*p[4],
        -         p[1]*p[3] - p[2]*p[4],
        -         p[2]*p[3] + p[1]*p[4],
        -         -p[1]^2 - p[2]^2
        -     ) 
        -     
        - end
        - 
        6 function getTiap(p)
        -     
        6     return SMatrix{3,3,Float64, 9}(
        -         p[1]^2 + p[4]^2,
        -         p[1]*p[2] - p[3]*p[4],
        -         p[1]*p[3] + p[2]*p[4],
        -         p[1]*p[2] + p[3]*p[4],
        -         p[2]^2 + p[4]^2,
        -         p[2]*p[3] - p[1]*p[4],
        -         p[1]*p[3] - p[2]*p[4],
        -         p[2]*p[3] + p[1]*p[4],
        -         p[3]^2 + p[4]^2
        -     ) 
        -     
        - end
        - 
        2 function getRka(p,dp)
        -     
        2     return SMatrix{3,3,Float64, 9}(
        - 
        -         -(dp[1,4]*p[1]) - dp[1,3]*p[2] + dp[1,2]*p[3] + dp[1,1]*p[4],
        -         -(dp[2,4]*p[1]) - dp[2,3]*p[2] + dp[2,2]*p[3] + dp[2,1]*p[4],
        -         -(dp[3,4]*p[1]) - dp[3,3]*p[2] + dp[3,2]*p[3] + dp[3,1]*p[4],
        -         dp[1,3]*p[1] - dp[1,4]*p[2] - dp[1,1]*p[3] + dp[1,2]*p[4],
        -         dp[2,3]*p[1] - dp[2,4]*p[2] - dp[2,1]*p[3] + dp[2,2]*p[4],
        -         dp[3,3]*p[1] - dp[3,4]*p[2] - dp[3,1]*p[3] + dp[3,2]*p[4],
        -         -(dp[1,2]*p[1]) + dp[1,1]*p[2] - dp[1,4]*p[3] + dp[1,3]*p[4],
        -         -(dp[2,2]*p[1]) + dp[2,1]*p[2] - dp[2,4]*p[3] + dp[2,3]*p[4],
        -         -(dp[3,2]*p[1]) + dp[3,1]*p[2] - dp[3,4]*p[3] + dp[3,3]*p[4],
        -     ) 
        -     
        - end
        - 
       16 function getLka(p,dp)
        - 
       16     return SMatrix{3,3,Float64, 9}(
        - 
        -     -(dp[1,4]*p[1]) + dp[1,3]*p[2] - dp[1,2]*p[3] + dp[1,1]*p[4],
        -     -(dp[2,4]*p[1]) + dp[2,3]*p[2] - dp[2,2]*p[3] + dp[2,1]*p[4],
        -     -(dp[3,4]*p[1]) + dp[3,3]*p[2] - dp[3,2]*p[3] + dp[3,1]*p[4],
        -     -(dp[1,3]*p[1]) - dp[1,4]*p[2] + dp[1,1]*p[3] + dp[1,2]*p[4],
        -     -(dp[2,3]*p[1]) - dp[2,4]*p[2] + dp[2,1]*p[3] + dp[2,2]*p[4],
        -     -(dp[3,3]*p[1]) - dp[3,4]*p[2] + dp[3,1]*p[3] + dp[3,2]*p[4],
        -     dp[1,2]*p[1] - dp[1,1]*p[2] - dp[1,4]*p[3] + dp[1,3]*p[4],
        -     dp[2,2]*p[1] - dp[2,1]*p[2] - dp[2,4]*p[3] + dp[2,3]*p[4],
        -     dp[3,2]*p[1] - dp[3,1]*p[2] - dp[3,4]*p[3] + dp[3,3]*p[4]
        - 
        -     )
        - 
        - end
        - 
        - 
        - function make_levi_civita()
        - 
        -     epsilon = zeros(3,3,3)
        - 	
        - 	epsilon[1,2,3] = 1.0
        - 	epsilon[1,3,2] = -1.0
        - 	epsilon[2,3,1] = 1.0
        - 	epsilon[2,1,3] = -1.0
        - 	epsilon[3,1,2] = 1.0
        - 	epsilon[3,2,1] = -1.0
        - 
        -     return epsilon
        - 
        - end
        - 
        - 
      120 function trace_su2_ij(Lia,Lib,i,j)
      120     return -2.0*(Lia[1,i]*Lib[1,j] + Lia[2,i]*Lib[2,j] + Lia[3,i]*Lib[3,j])
        - end
        - 
      360 function trace_su2_ijkl(L1,L2,L3,L4,i,j,k,l)
      360     return -8.0*(L1[i,1]*(L2[j,2]*(-(L3[k,2]*L4[l,1]) + L3[k,1]*L4[l,2]) + L2[j,3]*(-(L3[k,3]*L4[l,1]) + L3[k,1]*L4[l,3])) + L1[i,3]*(L2[j,1]*(L3[k,3]*L4[l,1] - L3[k,1]*L4[l,3]) + L2[j,2]*(L3[k,3]*L4[l,2] - L3[k,2]*L4[l,3])) + L1[i,2]*(L2[j,1]*(L3[k,2]*L4[l,1] - L3[k,1]*L4[l,2]) + L2[j,3]*(-(L3[k,3]*L4[l,2]) + L3[k,2]*L4[l,3])))
        - end
