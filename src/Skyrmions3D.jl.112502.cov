        - module Skyrmions3D
        - 
        - 
        - using Makie
        - using GLMakie, CairoMakie
        - using Optimization, OptimizationOptimJL, ForwardDiff, Symbolics
        - 
        - using Meshing, GeometryBasics, Interpolations, Colors, StaticArrays, LinearAlgebra
        - 
        - export Skyrmion, set_mpi!,  set_lattice!, set_Fpi!, set_ee!, set_physical!, set_lattice!
        - export set_periodic!, set_dirichlet!, set_neumann!
        - export check_if_normalised, normer!, normer
        - 
        - include("transform.jl")
        - export translate_sk, translate_sk!, isorotate_sk, isorotate_sk!, rotate_sk!, rotate_sk
        - export product_approx, product_approx!, center_skyrmion!
        - 
        - include("properties.jl")
        - export Energy, Baryon, center_of_mass, rms_baryon, compute_current, overview
        - 
        - include("initialise.jl")
        - export make_rational_map!, make_RM_product!, make_ADHM!, get_close_ADHM_data
        - 
        - include("plotting.jl")
        - export plot_field, plot_baryon_density, interactive_flow, plot_overview, plot_scan
        -  
        - include("derivatives.jl")
        - 
        - include("diff.jl")
        - export gradient_flow!, arrested_newton_flow!
        - 
        - 
        - """
        -     Skyrmion(lp::Int64, ls::Float64)
        - 	Skyrmion([lpx,lpy,lpx], [lsx,lsy,lsz])
        -     
        - Create a skyrme field with `lp` lattice points and `ls` lattice spacing. 
        - 
        - # Optional arguments
        - - `mpi = 0.0`: sets the pion mass for this Skyrme field
        - 
        - """
        - mutable struct Skyrmion
       11 	pion_field::Array{Float64, 4}
        - 	lp::Vector{Int64}
        - 	ls::Vector{Float64}
        - 	x::Vector{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}
        - 	mpi::Float64
        - 	Fpi::Float64
        - 	ee::Float64
        - 	physical::Bool
        - 	dirichlet::Bool
        - 	index_grid_x::Vector{Int64}
        - 	index_grid_y::Vector{Int64}
        - 	index_grid_z::Vector{Int64}
        - 	sum_grid::Vector{UnitRange{Int64}}
        - 	boundary_conditions::String
        - end
        - 
        - 
       18 Skyrmion(lp::Int64, ls::Float64; Fpi = 180, ee = 4.0, vac = [0.0,0.0,0.0,1.0], mpi = 0.0, boundary_conditions="dirichlet" ) = Skyrmion(vacuum_skyrmion(lp,lp,lp,vac) ,[lp,lp,lp],[ls,ls,ls], [ -ls*(lp - 1)/2.0 : ls : ls*(lp - 1)/2.0 for a in 1:3 ] , mpi, Fpi, ee, false, is_dirichlet(boundary_conditions),index_grid(lp,boundary_conditions), index_grid(lp,boundary_conditions), index_grid(lp,boundary_conditions), sum_grid(lp, boundary_conditions), boundary_conditions )
        - 
        7 Skyrmion(lp::Vector{Int64}, ls::Vector{Float64}; Fpi = 180, ee = 4.0, vac = [0.0,0.0,0.0,1.0], mpi = 0.0 , boundary_conditions="dirichlet") = Skyrmion(vacuum_skyrmion(lp[1],lp[2],lp[3],vac) ,lp, ls, [ -ls[a]*(lp[a] - 1)/2.0 : ls[a] : ls[a]*(lp[a] - 1)./2.0 for a in 1:3 ], mpi ,Fpi, ee, false, is_dirichlet(boundary_conditions),index_grid(lp[1],boundary_conditions), index_grid(lp[2],boundary_conditions), index_grid(lp[3],boundary_conditions), sum_grid(lp,boundary_conditions), boundary_conditions )
        - 
        - mutable struct profile
        -     field::Vector{Float64}
        -     lp::Int64
        -     ls::Float64
        -     r_grid::Vector{Float64}
        - end
        - 
        - profile(lp,ls) = profile( zeros(Float64,lp), lp, ls,  [ ls*i for i in 0:(lp-1) ] )
        - 
       11 function is_dirichlet(boundary_conditions)
        - 
       11 	if boundary_conditions == "dirichlet"
       11 		return true
        - 	else
        0 		return false
        - 	end
        - end
        - 
        - 
        - """
        -     set_mpi!(skyrmion::Skyrmion, mpi)
        - 
        - Set the pion mass of `skyrmion` to `mpi`.
        - """
        1 function set_mpi!(sk::Skyrmion, mpi)
        1 	sk.mpi = mpi
        - end
        - 
        - function set_periodic!(sk::Skyrmion, periodic::Bool)
        - 	
        - 	sk.periodic = periodic
        - 	sk.sum_grid = sum_grid(sk.lp, sk.periodic)
        - 
        - 	if dirichlet == false
        - 		println("Periodic boundary conditions activated")
        - 	else
        - 		set_dirichlet!(sk)
        - 		println("Dirichlet boundary conditions activated")
        - 	end
        - 
        - end
        - 
        - 
        - """
        - 	set_periodic!(skyrmion::Skyrmion)
        - 
        - Sets the `skyrmion` to have periodic boundary conditions.
        - """
        2 function set_periodic!(sk::Skyrmion)
        - 	
        2 	sk.dirichlet = false
        - 
        2 	sk.boundary_conditions = "periodic"
        2 	sk.sum_grid = sum_grid(sk.lp, sk.boundary_conditions)
        - 
        2 	sk.index_grid_x = index_grid(sk.lp[1], sk.boundary_conditions)
        2 	sk.index_grid_y = index_grid(sk.lp[2], sk.boundary_conditions)
        2 	sk.index_grid_z = index_grid(sk.lp[3], sk.boundary_conditions)
        - 
        2 	println("Periodic boundary conditions activated")
        - 
        - end
        - 
        - """
        - 	set_dirichlet!(skyrmion::Skyrmion)
        - 
        - Sets the `skyrmion` to have Dirichlet boundary conditions.
        - """
        5 function set_neumann!(sk::Skyrmion)
        - 
        5 	sk.dirichlet = false
        - 	
        5 	sk.boundary_conditions = "neumann"
        - 
        5 	sk.sum_grid = sum_grid(sk.lp, sk.boundary_conditions)
        5 	sk.index_grid_x = index_grid(sk.lp[1], sk.boundary_conditions)
        5 	sk.index_grid_y = index_grid(sk.lp[2], sk.boundary_conditions)
        5 	sk.index_grid_z = index_grid(sk.lp[3], sk.boundary_conditions)
        - 
        5 	println("Neumann boundary conditions activated")
        - 
        - end
        - 
        - """
        - 	set_dirichlet!(skyrmion::Skyrmion)
        - 
        - Sets the `skyrmion` to have periodic boundary conditions.
        - """
        3 function set_dirichlet!(sk::Skyrmion)
        - 
        3 	sk.dirichlet = true
        - 	
        3 	sk.boundary_conditions = "dirichlet"
        3 	sk.sum_grid = sum_grid(sk.lp, sk.boundary_conditions)
        - 
       12 	set_dirichlet_boudary!(sk)
        3 	println("Dirichlet boundary conditions activated")
        - 
        - end
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - """
        - 	set_Fpi!(skyrmion::Skyrmion, Fpi)
        - 
        - Sets the pion decay constant of `skyrmion` to `Fpi`. 
        - """
        1 function set_Fpi!(sk::Skyrmion, Fpi)
        - 	
        1 	sk.Fpi = Fpi
        - 
        - end
        - 
        - 
        - """
        - 	set_ee!(skyrmion::Skyrmion, ee)
        - 
        - Sets the Skyrme coupling constant of `skyrmion` to `ee`. 
        - """
        1 function set_ee!(sk::Skyrmion, ee)
        - 	
        1 	sk.ee = ee
        - 
        - end
        - 
        - 
        - """
        -     set_physical!(skyrmion::Skyrmion, is_physical; Fpi=Fpi, ee=ee)
        - 
        - Sets `skyrmion` to use physical units with `Fpi` MeV and skyrme coupling `ee`, when `is_physical` is `true`.
        - Also used to turn off physical units by setting is_physical=false
        - """
        4 function set_physical!(skyrmion::Skyrmion, physical::Bool; Fpi=skyrmion.Fpi, ee=skyrmion.ee)
        - 	
        2 	skyrmion.physical = physical
        - 
        2 	if skyrmion.physical == true
        1 		println("Fpi = ", skyrmion.Fpi, ",  e = ", skyrmion.ee, " and m = ", skyrmion.mpi)
        1 		println("Hence, mpi = ", skyrmion.Fpi*skyrmion.ee*skyrmion.mpi/2.0, ", length unit = ", 197.327*2.0/(skyrmion.ee*skyrmion.Fpi), "and energy unit = ", skyrmion.Fpi/(4.0*skyrmion.ee))
        - 	end
        - 
        - end
        - 
        - """
        -     set_lattice!(skyrmion, lp = [lpx, lpy, lpz], ls = [lsx, lsy, lsz])
        - 
        - Sets the underlying lattice to one with `lpx`x`lpy`x`lpz` points and `lsx`x`lsy`x`lsz` spacings, and reinterpolates `skyrmion` on the new grid.
        - 
        - """
        1 function set_lattice!(skyrmion, lp, ls)
        - 
        1     old_x = skyrmion.x
        1     x = setgrid(lp,ls)
        - 
        4     sky_temp = Skyrmion(lp, ls,  mpi = skyrmion.mpi , boundary_conditions = skyrmion.boundary_conditions)
        4     vac = [0.0,0.0,0.0,1.0]
        - 
        1     ϕinterp = [ extrapolate(scale(interpolate( skyrmion.pion_field[:,:,:,a] , BSpline(Quadratic()) ), (old_x[1],old_x[2],old_x[3]) ), Throw()) for a in 1:4 ]
        - 
       29     for k in 1:lp[3], j in 1:lp[2], i in 1:lp[1]
        - 
      168         if old_x[1][1] < x[1][i] < old_x[1][end] && old_x[2][1] < x[2][j] < old_x[2][end] && old_x[3][1] < x[3][k] < old_x[3][end]
       72             for a in 1:4
      288                 sky_temp.pion_field[i,j,k,a] = ϕinterp[a](x[1][i], x[2][j], x[3][k])
      504             end
        -         else
       96             sky_temp.pion_field[i,j,k,:] .= vac
        -         end
        -         
      174     end
        -     
        1     skyrmion.lp = sky_temp.lp
        1     skyrmion.ls = sky_temp.ls
        1     skyrmion.x = sky_temp.x
      672     skyrmion.pion_field = zeros(lp[1],lp[2],lp[3],4)
        1     skyrmion.pion_field .= sky_temp.pion_field
        - 
        1     skyrmion.index_grid_x = index_grid(lp[1], sky_temp.boundary_conditions)
        1     skyrmion.index_grid_y = index_grid(lp[2], sky_temp.boundary_conditions)
        1     skyrmion.index_grid_z = index_grid(lp[3], sky_temp.boundary_conditions)
        -     
        1     skyrmion.sum_grid = sum_grid(lp, sky_temp.boundary_conditions)
        -     
        1     normer!(skyrmion)
        1     if skyrmion.boundary_conditions == "dirichlet"
        1         set_dirichlet!(skyrmion)
        -     end
        - 
        1 	println("Your new lattice has ", lp[1],"*",lp[2],"*",lp[3]," points with lattice spacing [",ls[1],", ",ls[2],", ",ls[3],"].")
        - 
        - end
        - 
        - 
       11 function vacuum_skyrmion(lpx,lpy,lpz,vac)
        - 
     6400 	vac_sk = zeros(lpx,lpy,lpz,4)
        - 
      307 	for i in 1:lpx, j in 1:lpy, k in 1:lpz
     1600 		vac_sk[i,j,k,:] = vac
     1647 	end
        - 
       11 	return vac_sk
        - 
        - end
        - 
       12 function sum_grid(lp::Integer, boundary_conditions::String)
        - 
       12 	if boundary_conditions == "dirichlet"
       10 		return [ 3:lp-2, 3:lp-2, 3:lp-2]
        - 	else
        2 		return [ 1:lp, 1:lp, 1:lp ]
        - 	end
        - 
        - end
        - 
       16 function sum_grid(lp::Vector{Int64}, boundary_conditions::String)
        - 
       16 	if boundary_conditions == "dirichlet"
        7 		return [ 3:lp[1]-2, 3:lp[2]-2, 3:lp[3]-2]
        - 	else
        9 		return [ 1:lp[1], 1:lp[2], 1:lp[3] ]
        - 	end
        - 	
        - end
        - 
       61 function index_grid(lp, boundary_conditions::String)
        - 
      570 	index_grid_array = zeros(Int64, lp+4)
        - 
       61 	if boundary_conditions == "periodic"
        - 
       20 		for i in 1:lp+4
      192 			index_grid_array[i] = mod1(i-2,lp)
      182 		end
        - 
        - 	else
        - 
      102 		for i in 3:lp+2
      270 			index_grid_array[i] = i-2
      489 		end
        - 		
       51 		index_grid_array[1] = 2
       51 		index_grid_array[2] = 1
        - 		
       51 		index_grid_array[lp+3] = lp
       51 		index_grid_array[lp+4] = lp-1
        - 
        - 	end
        - 
       61 	return index_grid_array
        - 
        - end
        - 
        - 
        - 
        - """
        -     check_if_normalised(skyrmion)
        - 
        - Check if skyrmion is normalised.
        - 
        - Throws an error if any point is not normalised
        - 
        - """
        3 function check_if_normalised(skyrmion)
       58 	for i in 1:skyrmion.lp[1], j in 1:skyrmion.lp[2], k in 1:skyrmion.lp[3]
      380 		@assert  skyrmion.pion_field[i,j,k,1]^2 + skyrmion.pion_field[i,j,k,2]^2 + skyrmion.pion_field[i,j,k,3]^2 + skyrmion.pion_field[i,j,k,4]^2 ≈ 1.0 "nooo"
      378 	end
        - end
        - 
        - 
        - 
        - """
        -     setgrid(lp, ls)
        - 
        - Compute a Cartesian lattice with `lp` lattice points and `ls` lattice spacing.
        - 
        - `lp` and `ls` should be 3-vectors
        - 
        - """
        1 function setgrid(lp,ls)
        - 
        3 	x = [zeros(lp[1]), zeros(lp[2]), zeros(lp[3])]
        1 	for a in 1:3
        3 		x[a] = [-0.5*ls[a]*(lp[a]-1) + n*ls[a] for n=0:lp[a]-1]
        5 	end
        - 
        1 	return x
        - 
        - end
        - 
        - 
        - """
        -     normer!(skyrmion)
        - 
        - Normalises `skyrmion`.
        - 
        - See also [`normer`]
        - """
       20 function normer!(sk)
        - 
       20     normer!(sk.pion_field, sk.lp)
        - 
        - end
        - 
        - """
        -     normer(skyrmion)
        - 
        - Returns normalised `skyrmion`.
        - 
        - See also [`normer!`]
        - 
        - """
        1 function normer(sk)
        - 
        1     sk_new = deepcopy(sk)
        1     normer!(sk_new.pion_field, sk_new.lp)
        - 
        1 	return sk_new
        - 
        - end
        - 
        - 
       21 function normer!(pion_field::Array{Float64, 4}, lp)
        - 
       21 	Threads.@threads for k in 1:lp[3]
      606 		for j in 1:lp[2], i in 1:lp[1]
        - 			
     2566 			@inbounds normer = 1.0/sqrt( pion_field[i,j,k,1]^2 + pion_field[i,j,k,2]^2 + pion_field[i,j,k,3]^2 + pion_field[i,j,k,4]^2 )
     2555 			for a in 1:4
    10216 				@inbounds pion_field[i,j,k,a] *= normer
    17870 			end
        - 	
     2943 		end
        0 	end
        - end
        - 
        - end
